type Alert {
  severity: Severity!
  title: String!
  message: String!
  timestamp: DateTime
}

type Api {
  version: String!
  recoveryKey: ApiRecoveryKeyStatus!
  devices: [ApiDevice!]!
}

type ApiDevice {
  name: String!
  creationDate: DateTime!
  isCaller: Boolean!
}

type ApiJob {
  uid: String!
  name: String!
  description: String!
  status: String!
  statusText: String
  progress: Int
  createdAt: DateTime!
  updatedAt: DateTime!
  finishedAt: DateTime
  error: String
  result: String
}

type ApiKeyMutationReturn implements MutationReturnInterface {
  success: Boolean!
  message: String!
  code: Int!
  key: String
}

type ApiRecoveryKeyStatus {
  exists: Boolean!
  valid: Boolean!
  creationDate: DateTime
  expirationDate: DateTime
  usesLeft: Int
}

type AutoUpgradeOptions {
  enable: Boolean!
  allowReboot: Boolean!
}

input AutoUpgradeSettingsInput {
  enableAutoUpgrade: Boolean = null
  allowReboot: Boolean = null
}

type AutoUpgradeSettingsMutationReturn implements MutationReturnInterface {
  success: Boolean!
  message: String!
  code: Int!
  enableAutoUpgrade: Boolean!
  allowReboot: Boolean!
}

type Backup {
  configuration: BackupConfiguration!
  allSnapshots: [SnapshotInfo!]!
}

type BackupConfiguration {
  provider: BackupProvider!
  encryptionKey: String!
  isInitialized: Boolean!
  autobackupPeriod: Int
  locationName: String
  locationId: String
}

enum BackupProvider {
  BACKBLAZE
  NONE
  MEMORY
  FILE
}

"""Date with time (isoformat)"""
scalar DateTime

type DeviceApiTokenMutationReturn implements MutationReturnInterface {
  success: Boolean!
  message: String!
  code: Int!
  token: String
}

enum DnsProvider {
  CLOUDFLARE,
  DESEC,
  DIGITALOCEAN
}

type DnsRecord {
  recordType: String!
  name: String!
  content: String!
  ttl: Int!
  priority: Int
}

type GenericBackupConfigReturn implements MutationReturnInterface {
  success: Boolean!
  message: String!
  code: Int!
  configuration: BackupConfiguration
}

type GenericJobMutationReturn implements MutationReturnInterface {
  success: Boolean!
  message: String!
  code: Int!
  job: ApiJob
}

type GenericMutationReturn implements MutationReturnInterface {
  success: Boolean!
  message: String!
  code: Int!
}

input InitializeRepositoryInput {
  provider: BackupProvider!
  locationId: String!
  locationName: String!
  login: String!
  password: String!
}

type Job {
  getJobs: [ApiJob!]!
  getJob(jobId: String!): ApiJob
}

input MigrateToBindsInput {
  emailBlockDevice: String!
  bitwardenBlockDevice: String!
  giteaBlockDevice: String!
  nextcloudBlockDevice: String!
  pleromaBlockDevice: String!
}

input MoveServiceInput {
  serviceId: String!
  location: String!
}

type Mutation {
  getNewRecoveryApiKey(limits: RecoveryKeyLimitsInput = null): ApiKeyMutationReturn!
  useRecoveryApiKey(input: UseRecoveryKeyInput!): DeviceApiTokenMutationReturn!
  refreshDeviceApiToken: DeviceApiTokenMutationReturn!
  deleteDeviceApiToken(device: String!): GenericMutationReturn!
  getNewDeviceApiKey: ApiKeyMutationReturn!
  invalidateNewDeviceApiKey: GenericMutationReturn!
  authorizeWithNewDeviceApiKey(input: UseNewDeviceKeyInput!): DeviceApiTokenMutationReturn!
  changeTimezone(timezone: String!): TimezoneMutationReturn!
  changeAutoUpgradeSettings(settings: AutoUpgradeSettingsInput!): AutoUpgradeSettingsMutationReturn!
  runSystemRebuild: GenericMutationReturn!
  runSystemRollback: GenericMutationReturn!
  runSystemUpgrade: GenericMutationReturn!
  rebootSystem: GenericMutationReturn!
  pullRepositoryChanges: GenericMutationReturn!
  createUser(user: UserMutationInput!): UserMutationReturn!
  deleteUser(username: String!): GenericMutationReturn!
  updateUser(user: UserMutationInput!): UserMutationReturn!
  addSshKey(sshInput: SshMutationInput!): UserMutationReturn!
  removeSshKey(sshInput: SshMutationInput!): UserMutationReturn!
  resizeVolume(name: String!): GenericMutationReturn!
  mountVolume(name: String!): GenericMutationReturn!
  unmountVolume(name: String!): GenericMutationReturn!
  migrateToBinds(input: MigrateToBindsInput!): GenericJobMutationReturn!
  enableService(serviceId: String!): ServiceMutationReturn!
  disableService(serviceId: String!): ServiceMutationReturn!
  stopService(serviceId: String!): ServiceMutationReturn!
  startService(serviceId: String!): ServiceMutationReturn!
  restartService(serviceId: String!): ServiceMutationReturn!
  moveService(input: MoveServiceInput!): ServiceJobMutationReturn!
  removeJob(jobId: String!): GenericMutationReturn!
  initializeRepository(repository: InitializeRepositoryInput!): GenericBackupConfigReturn!
  removeRepository: GenericBackupConfigReturn!
  setAutobackupPeriod(period: Int = null): GenericBackupConfigReturn!
  startBackup(serviceId: String = null): GenericJobMutationReturn!
  restoreBackup(snapshotId: String!): GenericJobMutationReturn!
  forceSnapshotsReload: GenericMutationReturn!
  testMutation: GenericMutationReturn!
}

interface MutationReturnInterface {
  success: Boolean!
  message: String!
  code: Int!
}

type Query {
  system: System!
  api: Api!
  users: Users!
  storage: Storage!
  jobs: Job!
  services: Services!
  backup: Backup!
}

input RecoveryKeyLimitsInput {
  expirationDate: DateTime = null
  uses: Int = null
}

enum ServerProvider {
  HETZNER
  DIGITALOCEAN
}

type Service {
  id: String!
  displayName: String!
  description: String!
  svgIcon: String!
  isMovable: Boolean!
  isRequired: Boolean!
  isEnabled: Boolean!
  status: ServiceStatusEnum!
  url: String
  dnsRecords: [DnsRecord!]
  storageUsage: ServiceStorageUsage!
  backupSnapshots: [SnapshotInfo!]
}

type ServiceJobMutationReturn implements MutationReturnInterface {
  success: Boolean!
  message: String!
  code: Int!
  job: ApiJob
  service: Service
}

type ServiceMutationReturn implements MutationReturnInterface {
  success: Boolean!
  message: String!
  code: Int!
  service: Service
}

enum ServiceStatusEnum {
  ACTIVE
  RELOADING
  INACTIVE
  FAILED
  ACTIVATING
  DEACTIVATING
  OFF
}

type ServiceStorageUsage implements StorageUsageInterface {
  usedSpace: String!
  volume: StorageVolume
  title: String!
  service: Service
}

type Services {
  allServices: [Service!]!
}

enum Severity {
  INFO
  WARNING
  ERROR
  CRITICAL
  SUCCESS
}

type SnapshotInfo {
  id: String!
  service: Service!
  createdAt: DateTime!
}

input SshMutationInput {
  username: String!
  sshKey: String!
}

type SshSettings {
  enable: Boolean!
  passwordAuthentication: Boolean!
  rootSshKeys: [String!]!
}

type Storage {
  volumes: [StorageVolume!]!
}

interface StorageUsageInterface {
  usedSpace: String!
  volume: StorageVolume
  title: String!
}

type StorageVolume {
  totalSpace: String!
  freeSpace: String!
  usedSpace: String!
  root: Boolean!
  name: String!
  model: String
  serial: String
  type: String!
  usages: [StorageUsageInterface!]!
}

type Subscription {
  count(target: Int! = 100): Int!
}

type System {
  status: Alert!
  domainInfo: SystemDomainInfo!
  settings: SystemSettings!
  info: SystemInfo!
  provider: SystemProviderInfo!
  busy: Boolean!
  workingDirectory: String!
}

type SystemDomainInfo {
  domain: String!
  hostname: String!
  provider: DnsProvider!
  requiredDnsRecords: [DnsRecord!]!
}

type SystemInfo {
  systemVersion: String!
  pythonVersion: String!
  usingBinds: Boolean!
}

type SystemProviderInfo {
  provider: ServerProvider!
  id: String!
}

type SystemSettings {
  autoUpgrade: AutoUpgradeOptions!
  ssh: SshSettings!
  timezone: String!
}

type TimezoneMutationReturn implements MutationReturnInterface {
  success: Boolean!
  message: String!
  code: Int!
  timezone: String
}

input UseNewDeviceKeyInput {
  key: String!
  deviceName: String!
}

input UseRecoveryKeyInput {
  key: String!
  deviceName: String!
}

type User {
  userType: UserType!
  username: String!
  sshKeys: [String!]!
}

input UserMutationInput {
  username: String!
  password: String!
}

type UserMutationReturn implements MutationReturnInterface {
  success: Boolean!
  message: String!
  code: Int!
  user: User
}

enum UserType {
  NORMAL
  PRIMARY
  ROOT
}

type Users {
  allUsers: [User!]!
  getUser(username: String!): User
}

fragment dnsRecordFields on DnsRecord {
  content
  name
  priority
  recordType
  ttl
}

fragment backupSnapshotFields on SnapshotInfo {
  id
  createdAt
}
